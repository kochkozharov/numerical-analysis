\documentclass[a4paper, 12pt]{article}
\usepackage{cmap}
\usepackage[12pt]{extsizes}			
\usepackage{mathtext} 				
\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,greek,russian]{babel}
\usepackage{setspace}
\singlespacing
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools}
\usepackage{pmboxdraw}
\usepackage{fancyhdr}
\usepackage{soulutf8}
\usepackage{euscript}
\usepackage{enumitem}
\usepackage{mathrsfs}
\usepackage{array}
\usepackage{booktabs}
\usepackage{graphicx} 
\usepackage{caption}
\usepackage{listings}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{textgreek}

\usepackage[colorlinks=true, urlcolor=blue, linkcolor=black]{hyperref}

\pagestyle{fancy}
\usepackage{indentfirst}
\usepackage[top=10mm]{geometry}
\rhead{}
\lhead{}
\renewcommand{\headrulewidth}{0mm}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[dvipsnames]{xcolor}

\lstdefinestyle{mystyle}{ 
	keywordstyle=\color{OliveGreen},
	numberstyle=\tiny\color{Gray},
	stringstyle=\color{BurntOrange},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\thispagestyle{empty}
\begin{center}
    Московский авиационный институт

    (Национальный исследовательский университет)

    Факультет "Информационные технологии и прикладная математика"

    Кафедра "Вычислительная математика и программирование"

\end{center}
\vspace{40ex}
\begin{center}
    \textbf{\large{Отчёт по лабораторным работам \linebreak по дисциплине \linebreak\textquotedblleft Численные методы\textquotedblright}}
\end{center}
\vspace{35ex}
\begin{flushright}
    \textit{Студент: } Кочкожаров Иван Вячеславович

    \vspace{2ex}
    \textit{Группа: } М8О-408Б-22

    \vspace{2ex}
    \textit{Преподаватель: } Сеченых П. А.


\end{flushright}

\begin{vfill}
    \begin{center}
        Москва, 2025
    \end{center}
\end{vfill}
\newpage


\begingroup
\color{black}
\tableofcontents\newpage
\endgroup

\section{Лабораторная работа 5}


\subsection{Цель работы}

Используя явную и неявную конечно-разностные схемы, а также схему 
Кранка - Николсона, решить начально-краевую задачу для дифференциального 
уравнения параболического типа. Осуществить реализацию трех вариантов 
аппроксимации граничных условий, содержащих производные: двухточечная 
аппроксимация с первым порядком, трехточечная аппроксимация со вторым порядком, 
двухточечная аппроксимация со вторым порядком. В различные моменты времени 
вычислить погрешность численного решения путем сравнения результатов с 
приведенным в задании аналитическим решением $ U(x, t) $. Исследовать 
зависимость погрешности от сеточных параметров $ \tau, h $.

\subsection*{Вариант 9}
$$
\frac{\partial u}{\partial t} = a \frac{\partial^2 u}{\partial x^2} + b \frac{\partial u}{\partial x}, \quad a > 0, \quad b > 0.
$$

$$
u_x(0,t) - u(0,t) = -\exp(-at)(\cos(bt) + \sin(bt)),
$$

$$
u_x(\pi,t) - u(\pi,t) = \exp(-at)(\cos(bt) + \sin(bt)),
$$

$$
u(x,0) = \cos x,
$$

Аналитическое решение: $$ U(x,t) = \exp(-at)\cos(x + bt). $$


\subsection{Методы и реализация}

В работе проведено численное решение начально-краевой задачи для уравнения конвекции-диффузии параболического типа с использованием явной, неявной и схемы Кранка-Николсона. Все схемы реализованы на равномерной пространственно-временной сетке. Уравнение аппроксимировано конечно-разностными операторами второго порядка по пространству и первым (явная и неявная схемы) или вторым (схема Кранка-Николсона) порядком по времени. Особое внимание уделено аппроксимации граничных условий, содержащих производные: реализованы трехточечная аппроксимация второго порядка, двухточечная аппроксимация первого порядка и двухточечная аппроксимация второго порядка. Для решения систем линейных уравнений, возникающих в неявной схеме и схеме Кранка-Николсона, использован метод прогонки. На каждом временном слое вычислены максимальная и средняя абсолютные погрешности по сравнению с аналитическим решением. Проведено исследование зависимости погрешности от шагов по пространству и времени для всех комбинаций схем и аппроксимаций граничных условий, результаты визуализированы в виде графиков.

\subsection{Результаты}
\begin{verbatim}
================================================================================
Лабораторная работа 5: Численные методы решения параболических уравнений
Вариант 9
================================================================================
Параметры: a = 1.0, b = 1.0
Сетка: n_x = 50, n_t = 100
Шаги: h = 0.062832, τ = 0.010000
================================================================================

Явная схема + Двухточечная 1-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 2.253433e-01
L2 норма погрешности: 7.322738e-01

Явная схема + Трехточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 2.087458e-02
L2 норма погрешности: 6.057175e-02

Явная схема + Двухточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 1.736218e-02
L2 норма погрешности: 5.073255e-02

Неявная схема + Двухточечная 1-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 2.597388e-01
L2 норма погрешности: 8.406618e-01

Неявная схема + Трехточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 4.228641e-03
L2 норма погрешности: 4.235896e-02

Неявная схема + Двухточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 5.665499e-03
L2 норма погрешности: 4.725268e-02

Кранк-Николсон схема + Двухточечная 1-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 2.436362e-01
L2 норма погрешности: 7.822316e-01

Кранк-Николсон схема + Трехточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 2.970974e-03
L2 норма погрешности: 8.370262e-03

Кранк-Николсон схема + Двухточечная 2-го порядка
--------------------------------------------------------------------------------
Максимальная погрешность: 3.263377e-04
L2 норма погрешности: 2.668578e-03

================================================================================
Исследование зависимости погрешности от параметров сетки
================================================================================

Исследование для: Явная + Двухточечная 1-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    7.467505e-01    1.749573e+00
    0.157080     0.013333    7.720474e-01    2.193380e+00
    0.157080     0.010000    7.663781e-01    2.493218e+00
    0.157080     0.006667    7.849405e-01    3.115476e+00
    0.157080     0.005000    7.943990e-01    3.633712e+00

Исследование для: Явная + Трехточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    4.551410e-02    1.007556e-01
    0.157080     0.013333    3.525079e-02    9.290823e-02
    0.157080     0.010000    1.963859e-02    6.931282e-02
    0.157080     0.006667    1.798075e-02    7.057294e-02
    0.157080     0.005000    1.714168e-02    7.416133e-02

Исследование для: Явная + Двухточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    2.738875e-02    6.355605e-02
    0.157080     0.013333    1.693344e-02    4.740569e-02
    0.157080     0.010000    3.550757e-03    2.972337e-02
    0.157080     0.006667    1.392884e-03    1.736912e-02
    0.157080     0.005000    7.630050e-04    1.086362e-02

Исследование для: Неявная + Двухточечная 1-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    8.876907e-01    2.064404e+00
    0.157080     0.013333    8.654457e-01    2.446489e+00
    0.157080     0.010000    8.546512e-01    2.779223e+00
    0.157080     0.006667    8.440673e-01    3.349033e+00
    0.157080     0.005000    8.388525e-01    3.836004e+00

Исследование для: Неявная + Трехточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    8.961283e-03    6.252617e-02
    0.157080     0.013333    7.762579e-03    5.478521e-02
    0.157080     0.010000    9.509241e-03    5.266338e-02
    0.157080     0.006667    1.122779e-02    5.461237e-02
    0.157080     0.005000    1.207671e-02    5.932670e-02

Исследование для: Неявная + Двухточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    1.430656e-02    7.776927e-02
    0.157080     0.013333    1.078150e-02    6.895411e-02
    0.157080     0.010000    9.060380e-03    6.459049e-02
    0.157080     0.006667    7.366072e-03    6.084020e-02
    0.157080     0.005000    6.528796e-03    5.978326e-02

Исследование для: Кранк-Николсон + Двухточечная 1-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    7.950260e-01    1.849559e+00
    0.157080     0.013333    8.043870e-01    2.274561e+00
    0.157080     0.010000    8.091164e-01    2.631805e+00
    0.157080     0.006667    8.138793e-01    3.229853e+00
    0.157080     0.005000    8.162736e-01    3.733299e+00

Исследование для: Кранк-Николсон + Трехточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    1.505469e-02    3.127378e-02
    0.157080     0.013333    1.484324e-02    3.734970e-02
    0.157080     0.010000    1.475786e-02    4.264765e-02
    0.157080     0.006667    1.468602e-02    5.170000e-02
    0.157080     0.005000    1.465518e-02    5.941418e-02

Исследование для: Кранк-Николсон + Двухточечная 2-го порядка
Результаты (первые 5):
           h            τ       Max Error        L2 Error
------------------------------------------------------------
    0.157080     0.020000    2.014503e-03    1.230462e-02
    0.157080     0.013333    2.099137e-03    1.571280e-02
    0.157080     0.010000    2.605796e-03    1.865150e-02
    0.157080     0.006667    3.100691e-03    2.354497e-02
    0.157080     0.005000    3.343762e-03    2.761927e-02

================================================================================
Сводная таблица результатов
================================================================================
Схема                Граничные условия                    Max Error        L2 Error
--------------------------------------------------------------------------------
Явная                Двухточечная 1-го порядка         2.253433e-01    7.322738e-01
Явная                Трехточечная 2-го порядка         2.087458e-02    6.057175e-02
Явная                Двухточечная 2-го порядка         1.736218e-02    5.073255e-02
Неявная              Двухточечная 1-го порядка         2.597388e-01    8.406618e-01
Неявная              Трехточечная 2-го порядка         4.228641e-03    4.235896e-02
Неявная              Двухточечная 2-го порядка         5.665499e-03    4.725268e-02
Кранк-Николсон       Двухточечная 1-го порядка         2.436362e-01    7.822316e-01
Кранк-Николсон       Трехточечная 2-го порядка         2.970974e-03    8.370262e-03
Кранк-Николсон       Двухточечная 2-го порядка         3.263377e-04    2.668578e-03

================================================================================
Все графики сохранены в папку: lab5/results
================================================================================

\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Кранк-Николсон Двухточечная 1-го порядка}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_2-го_порядка.png}
\caption{Кранк-Николсон Двухточечная 2-го порядка}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Трехточечная_2-го_порядка.png}
\caption{Кранк-Николсон Трехточечная 2-го порядка}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Неявная_Двухточечная_1-го_порядка.png}
\caption{Неявная Двухточечная 1-го порядка}
\label{fig:my_image}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Неявная_Двухточечная_2-го_порядка.png}
\caption{Неявная Трехточечная 2-го порядка}
\label{fig:my_image}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Неявная_Трехточечная_2-го_порядка.png}
\caption{Неявная Трехточечная 2-го порядка}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Явная_Двухточечная_1-го_порядка.png}
\caption{Явная Двухточечная 1-го порядка}
\label{fig:my_image}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Явная_Двухточечная_2-го_порядка.png}
\caption{Явная Двухточечная 2-го порядка}
\label{fig:my_image}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Явная_Трехточечная_2-го_порядка}
\caption{Явная Трехточечная 2-го порядка}
\label{fig:my_image}
\end{figure}


\subsubsection{Код}

\begin{minted}{python}
def explicit_scheme(
    u: np.ndarray,
    h: float,
    tau: float,
    boundary_func: Callable[[np.ndarray, float, float, float], None],
    f_left: float,
    f_right: float,
) -> np.ndarray:
    u_new = u.copy()
    n = len(u)
    
    max_tau_diff = h * h / (2 * A)
    max_tau_conv = h / B if B > 0 else np.inf
    max_tau = min(max_tau_diff, max_tau_conv)
    
    if np.any(~np.isfinite(u)):
        return np.full(n, np.nan)
    
    if tau > max_tau:
        num_substeps = int(np.ceil(tau / max_tau)) + 1
        tau_sub = tau / num_substeps
        for _ in range(num_substeps):
            u_prev = u_new.copy()
            u_tmp = u_new.copy()
            for i in range(1, n - 1):
                if not np.isfinite(u_prev[i + 1]) or not np.isfinite(u_prev[i]) 
                or not np.isfinite(u_prev[i - 1]):
                    return np.full(n, np.nan)
                
                u_xx = (u_prev[i + 1] - 2 * u_prev[i] + u_prev[i - 1]) / (h * h)
                u_x = (u_prev[i + 1] - u_prev[i - 1]) / (2 * h)
                
                if not np.isfinite(u_xx) or not np.isfinite(u_x):
                    return np.full(n, np.nan)
                
                u_tmp[i] = u_prev[i] + tau_sub * (A * u_xx + B * u_x)
                
                if not np.isfinite(u_tmp[i]) or abs(u_tmp[i]) > 1e10:
                    return np.full(n, np.nan)

            u_new = u_tmp
            
            if boundary_func is apply_boundary_condition_two_point_second_order:
                coef_l = 1.0 + h + (h * h / (2.0 * A)) * (1.0 / tau_sub - B)
                const_l = h * f_left + (h * h / (2.0 * A)) * (-(u_prev[0] / tau_sub) - B * f_left)
                if abs(coef_l) < 1e-15:
                    return np.full(n, np.nan)
                u_new[0] = (u_new[1] - const_l) / coef_l

                coef_r = 1.0 - h + (h * h / (2.0 * A)) * (1.0 / tau_sub - B)
                const_r = -h * f_right + (h * h / (2.0 * A)) * (-(u_prev[-1] / tau_sub) - B * f_right)
                if abs(coef_r) < 1e-15:
                    return np.full(n, np.nan)
                u_new[-1] = (u_new[-2] - const_r) / coef_r
            else:
                boundary_func(u_new, h, f_left, f_right)
            
            if np.any(~np.isfinite(u_new)):
                return np.full(n, np.nan)
    else:
        for i in range(1, n - 1):
            if not np.isfinite(u[i + 1]) or not np.isfinite(u[i]) or not np.isfinite(u[i - 1]):
                return np.full(n, np.nan)
            
            u_xx = (u[i + 1] - 2 * u[i] + u[i - 1]) / (h * h)
            u_x = (u[i + 1] - u[i - 1]) / (2 * h)
            
            if not np.isfinite(u_xx) or not np.isfinite(u_x):
                return np.full(n, np.nan)
            
            u_new[i] = u[i] + tau * (A * u_xx + B * u_x)
            
            if not np.isfinite(u_new[i]) or abs(u_new[i]) > 1e10:
                return np.full(n, np.nan)

        if boundary_func is apply_boundary_condition_two_point_second_order:
            coef_l = 1.0 + h + (h * h / (2.0 * A)) * (1.0 / tau - B)
            const_l = h * f_left + (h * h / (2.0 * A)) * (-(u[0] / tau) - B * f_left)
            if abs(coef_l) < 1e-15:
                return np.full(n, np.nan)
            u_new[0] = (u_new[1] - const_l) / coef_l

            coef_r = 1.0 - h + (h * h / (2.0 * A)) * (1.0 / tau - B)
            const_r = -h * f_right + (h * h / (2.0 * A)) * (-(u[-1] / tau) - B * f_right)
            if abs(coef_r) < 1e-15:
                return np.full(n, np.nan)
            u_new[-1] = (u_new[-2] - const_r) / coef_r
        else:
            boundary_func(u_new, h, f_left, f_right)
        
        if np.any(~np.isfinite(u_new)):
            return np.full(n, np.nan)
    
    return u_new

def implicit_scheme(
    u: np.ndarray,
    h: float,
    tau: float,
    boundary_func: Callable[[np.ndarray, float, float, float], None],
    f_left: float,
    f_right: float,
) -> np.ndarray:
    n = len(u)

    if n < 3:
        return u.copy()
    
    alpha = tau * A / (h * h)
    beta = tau * B / (2 * h)
    gamma = 1.0
    
    if np.any(~np.isfinite(u)):
        return np.full(n, np.nan)

    (p1, p2, q), (r1, r2, s) = _boundary_relations(boundary_func, h, f_left, f_right)
    if boundary_func is apply_boundary_condition_two_point_second_order:
        k_l = 1.0 - (h * B) / (2.0 * A)
        denom_l = k_l + (1.0 / h) + h / (2.0 * A * tau)
        k_r = 1.0 + (h * B) / (2.0 * A)
        denom_r = (1.0 / h) + h / (2.0 * A * tau) - k_r
        if abs(denom_l) < 1e-15 or abs(denom_r) < 1e-15:
            return np.full(n, np.nan)

        p1 = (1.0 / h) / denom_l
        p2 = 0.0
        q = ((h / (2.0 * A * tau)) * u[0] - k_l * f_left) / denom_l

        r1 = (1.0 / h) / denom_r
        r2 = 0.0
        s = ((h / (2.0 * A * tau)) * u[-1] + k_r * f_right) / denom_r

    m = n - 2
    a_red = np.zeros(m)
    b_red = np.zeros(m)
    c_red = np.zeros(m)
    d_red = np.zeros(m)

    a0 = -alpha + beta
    b0 = gamma + 2.0 * alpha
    c0 = -alpha - beta

    i = 1
    j = 0
    b_red[j] = b0 + a0 * p1
    c_red[j] = c0 + a0 * p2
    d_red[j] = u[i] - a0 * q

    for i in range(2, n - 2):
        j = i - 1
        a_red[j] = a0
        b_red[j] = b0
        c_red[j] = c0
        d_red[j] = u[i]

    i = n - 2
    j = m - 1
    a_red[j] = a0 + c0 * r2
    b_red[j] = b0 + c0 * r1
    c_red[j] = 0.0
    d_red[j] = u[i] - c0 * s

    u_inner = thomas_algorithm(a_red, b_red, c_red, d_red)
    if np.any(~np.isfinite(u_inner)):
        return np.full(n, np.nan)

    u_new = u.copy()
    u_new[1:-1] = u_inner
    u_new[0] = p1 * u_new[1] + p2 * u_new[2] + q
    u_new[-1] = r1 * u_new[-2] + r2 * u_new[-3] + s

    if np.any(~np.isfinite(u_new)):
        return np.full(n, np.nan)

    return u_new


def crank_nicolson_scheme(
    u: np.ndarray,
    h: float,
    tau: float,
    boundary_func: Callable[[np.ndarray, float, float, float], None],
    f_left: float,
    f_right: float,
) -> np.ndarray:
    n = len(u)

    if n < 3:
        return u.copy()
    
    alpha = tau * A / (2 * h * h)
    beta = tau * B / (4 * h)
    gamma = 1.0
    
    if np.any(~np.isfinite(u)):
        return np.full(n, np.nan)
    
    explicit_rhs = np.zeros(n)
    for i in range(1, n - 1):
        if not np.isfinite(u[i + 1]) or not np.isfinite(u[i]) or not np.isfinite(u[i - 1]):
            return np.full(n, np.nan)
        
        u_xx_n = (u[i + 1] - 2 * u[i] + u[i - 1]) / (h * h)
        u_x_n = (u[i + 1] - u[i - 1]) / (2 * h)
        
        if not np.isfinite(u_xx_n) or not np.isfinite(u_x_n):
            return np.full(n, np.nan)
        
        explicit_rhs[i] = u[i] + (tau / 2) * (A * u_xx_n + B * u_x_n)
        
        if not np.isfinite(explicit_rhs[i]) or abs(explicit_rhs[i]) > 1e10:
            return np.full(n, np.nan)
    
    (p1, p2, q), (r1, r2, s) = _boundary_relations(boundary_func, h, f_left, f_right)
    if boundary_func is apply_boundary_condition_two_point_second_order:
        k_l = 1.0 - (h * B) / (2.0 * A)
        denom_l = k_l + (1.0 / h) + h / (2.0 * A * tau)
        k_r = 1.0 + (h * B) / (2.0 * A)
        denom_r = (1.0 / h) + h / (2.0 * A * tau) - k_r
        if abs(denom_l) < 1e-15 or abs(denom_r) < 1e-15:
            return np.full(n, np.nan)

        p1 = (1.0 / h) / denom_l
        p2 = 0.0
        q = ((h / (2.0 * A * tau)) * u[0] - k_l * f_left) / denom_l

        r1 = (1.0 / h) / denom_r
        r2 = 0.0
        s = ((h / (2.0 * A * tau)) * u[-1] + k_r * f_right) / denom_r

    m = n - 2
    a_red = np.zeros(m)
    b_red = np.zeros(m)
    c_red = np.zeros(m)
    d_red = np.zeros(m)

    a0 = -alpha + beta
    b0 = gamma + 2.0 * alpha
    c0 = -alpha - beta

    i = 1
    j = 0
    b_red[j] = b0 + a0 * p1
    c_red[j] = c0 + a0 * p2
    d_red[j] = explicit_rhs[i] - a0 * q

    for i in range(2, n - 2):
        j = i - 1
        a_red[j] = a0
        b_red[j] = b0
        c_red[j] = c0
        d_red[j] = explicit_rhs[i]

    i = n - 2
    j = m - 1
    a_red[j] = a0 + c0 * r2
    b_red[j] = b0 + c0 * r1
    c_red[j] = 0.0
    d_red[j] = explicit_rhs[i] - c0 * s

    u_inner = thomas_algorithm(a_red, b_red, c_red, d_red)
    if np.any(~np.isfinite(u_inner)):
        return np.full(n, np.nan)

    u_new = u.copy()
    u_new[1:-1] = u_inner
    u_new[0] = p1 * u_new[1] + p2 * u_new[2] + q
    u_new[-1] = r1 * u_new[-2] + r2 * u_new[-3] + s

    if np.any(~np.isfinite(u_new)):
        return np.full(n, np.nan)

    return u_new
\end{minted}

\subsection{Вывод}

Проведенные расчеты подтвердили работоспособность всех реализованных методов и продемонстрировали существенное влияние аппроксимации граничных условий на точность решения. Наилучшие результаты получены для схемы Кранка-Николсона с двухточечной аппроксимацией второго порядка (погрешность 3.26e-04), что соответствует её теоретическому второму порядку точности. Трехточечная и двухточечная аппроксимации второго порядка показали близкую эффективность, превосходя аппроксимацию первого порядка на 1-2 порядка величины. Исследование зависимости погрешности от параметров сетки подтвердило ожидаемые свойства устойчивости: явная схема требовала выполнения условия Куранта, тогда как неявная и схема Кранка-Николсона сохраняли устойчивость при любых шагах, демонстрируя практическую применимость для широкого диапазона сеточных параметров.
\newpage

\section{Лабораторная работа 6}

\subsection{Цель работы}

Используя явную схему крест и неявную схему, решить начально-краевую задачу 
для дифференциального уравнения гиперболического типа. Осуществить реализацию 
трех вариантов аппроксимации граничных условий, содержащих производные: 
двухточечная аппроксимация с первым порядком, трехточечная аппроксимация со вторым порядком, 
двухточечная аппроксимация со вторым порядком. В различные моменты времени вычислить 
погрешность численного решения путем сравнения результатов с приведенным в задании аналитическим решением U(x, t).

\subsection*{Вариант 9}
$$\frac{\partial^2 u}{\partial t^2} = \frac{\partial^2 u}{\partial x^2} - 3u,$$
$$u(0, t) = \sin(2t),$$
$$u(\pi, t) = - \sin(2t),$$
$$u(x, 0) = 0,$$
$$u_t(x, 0) = 2 \cos x.$$
\text{Аналитическое решение: } $$U(x, t) = \cos x \sin(2t).$$

\subsection{Методы и реализация}

В работе проведено численное решение начально-краевой задачи для волнового уравнения гиперболического типа с учетом слагаемого -3u. Для решения использованы две конечно-разностные схемы: явная схема "крест" и неявная схема. Обе схемы реализованы на равномерной пространственно-временной сетке. Производные аппроксимированы центральными разностями второго порядка точности. Для запуска разностной схемы, требующей значений на двух временных слоях, второй начальный слой (при $t = \tau$ ) был вычислен с использованием начального условия для первой производной по времени по формуле с первым порядком аппроксимации. Граничные условия первого рода аппроксимированы точно. Решение систем линейных уравнений с трехдиагональной матрицей, возникающих в неявной схеме, выполнено эффективным методом прогонки. Для оценки точности на каждом временном слое вычислялись максимальная и средняя абсолютные погрешности численного решения по сравнению с аналитическим. Дополнительно построены графики распределения решения в заданный момент времени и графики зависимости максимальной погрешности от времени для визуального сравнения свойств схем.

\subsection{Результаты}
\begin{verbatim}
Погрешность явной конечно-разностной схемы в сравнении с аналитическим решением:
max abs error = 0.00010771631568373685
mean abs error = 3.0508798123563695e-05

Погрешность неявной конечно-разностной схемы в сравнении с аналитическим решением:
max abs error = 0.041387088530764636
mean abs error = 0.010870226942435904

\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\subsubsection{Код}

\begin{minted}{python}
import math
import numpy as np
import matplotlib.pyplot as plt
     

x_begin = 0
x_end = math.pi

t_begin = 0
t_end = 10

h = 0.01
sigma = 1
     

# boundary conditions
def phi_0(t):
    return math.sin(2*t)

def phi_1(t):
    return -math.sin(2*t)

# initial conditions
def psi_0(x):
    return 0

def psi_1(x):
    return 2 * math.cos(x)

def solution(x, t):
    return math.cos(x) * math.sin(2*t)

def get_analytical_solution(
    x_range, # (x_begin, x_end)
    t_range, # (t_begin, t_end)
    h, # len of cell by x
    sigma=sigma, # coefficient sigma
):
    """
    Get analytical solution of hyperbolic DE
    Returns matrix U with values of function
    """
    tau = np.sqrt(sigma * h**2) # len of cell by t
    x = np.arange(*x_range, h)
    t = np.arange(*t_range, tau)

    res = np.zeros((len(t), len(x)))
    for idx in range(len(x)):
        for idt in range(len(t)):
            res[idt][idx] = solution(x[idx], t[idt])

    return res
     

analytical_solution = get_analytical_solution(
    x_range=(x_begin, x_end),
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)
     

solutions = dict()
solutions["analytical solution"] = analytical_solution

def max_abs_error(A, B):
    """
    Calculate max absolute error of elements of matrices A and B
    """
    assert A.shape == B.shape
    return abs(A - B).max()

def mean_abs_error(A, B):
    """
    Calculate mean absolute error of elements of matrices A and B
    """
    assert A.shape == B.shape
    return abs(A - B).mean()

def explicit_finite_difference_method(
    x_range, # (x_begin, x_end)
    t_range, # (t_begin, t_end)
    h, # len of cell by x
    sigma, # coefficient sigma
    phi_0=phi_0, # boundary condition 0
    phi_1=phi_1, # boundary condition 1
    psi_0=psi_0, # initial condition 0,
    psi_1=psi_1, # initial condition 1 (first derivative),
):
    """
    Solves hyperbolic DE using explicit schema of finite difference method.
    Returns matrix U with values of function
    """
    tau = np.sqrt(sigma * h**2) # len of cell by t
    x = np.arange(*x_range, h)
    t = np.arange(*t_range, tau)

    res = np.zeros((len(t), len(x)))
    # row 0 -> use initial condition 0
    for col_id in range(len(x)):
        res[0][col_id] = psi_0(x[col_id])

    # row 1 -> use approximation
    for col_id in range(len(x)):
        res[1][col_id] = psi_0(x[col_id]) + tau * psi_1(x[col_id])

    for row_id in range(2, len(t)):
        # col 0 -> use boundary condition 0
        res[row_id][0] = phi_0(t[row_id])
        # cols 1..n-1 -> use explicit schema
        for col_id in range(1, len(x)-1):
            res[row_id][col_id] = (
                sigma * (
                    res[row_id-1][col_id+1]
                    - 2 * res[row_id-1][col_id]
                    + res[row_id-1][col_id-1]
                )
                + (2 - 3 * tau**2) * res[row_id-1][col_id]
                - res[row_id-2][col_id]
            )
        # col n -> use boundary condition 1
        res[row_id][-1] = phi_1(t[row_id])
    return res
     

explicit_solution = explicit_finite_difference_method(
    x_range=(x_begin, x_end),
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)

     

solutions["explicit schema"] = explicit_solution

print(f'max abs error = {max_abs_error(explicit_solution, analytical_solution)}')
print(f'mean abs error = {mean_abs_error(explicit_solution, analytical_solution)}')

def tridiagonal_solve(A, b):
    """
    Solves Ax=b, where A - tridiagonal matrix
    Returns x
    """
    n = len(A)
    # Step 1. Forward
    v = [0 for _ in range(n)]
    u = [0 for _ in range(n)]
    v[0] = A[0][1] / -A[0][0]
    u[0] = b[0] / A[0][0]
    for i in range(1, n-1):
        v[i] = A[i][i+1] / (-A[i][i] - A[i][i-1] * v[i-1])
        u[i] = (A[i][i-1] * u[i-1] - b[i]) / (-A[i][i] - A[i][i-1] * v[i-1])
    v[n-1] = 0
    u[n-1] = (A[n-1][n-2] * u[n-2] - b[n-1]) / (-A[n-1][n-1] - A[n-1][n-2] * v[n-2])

    # Step 2. Backward
    x = [0 for _ in range(n)]
    x[n-1] = u[n-1]
    for i in range(n-1, 0, -1):
        x[i-1] = v[i-1] * x[i] + u[i-1]
    return np.array(x)
     

def implicit_finite_difference_method(
    x_range, # (x_begin, x_end)
    t_range, # (t_begin, t_end)
    h, # len of cell by x
    sigma, # coefficient sigma
    phi_0=phi_0, # boundary condition 0
    phi_1=phi_1, # boundary condition 1
    psi_0=psi_0, # initial condition 0,
    psi_1=psi_1, # initial condition 1 (first derivative),
):
    """
    Solves hyperbolic DE using implicit schema of finite difference method.
    Returns matrix U with values of function
    """
    tau = np.sqrt(sigma * h**2) # len of cell by t
    x = np.arange(*x_range, h)
    t = np.arange(*t_range, tau)
    res = np.zeros((len(t), len(x)))

    # row 0 -> use initial condition
    for col_id in range(len(x)):
        res[0][col_id] = psi_0(x[col_id])

    # row 1 -> use approximation
    for col_id in range(len(x)):
        res[1][col_id] = psi_0(x[col_id]) + tau * psi_1(x[col_id])

    for row_id in range(2, len(t)):
        A = np.zeros((len(x)-2, len(x)-2)) # first and last elements will be counted with boundary conditions

        # create system of equations for implicit schema
        A[0][0] = -(1 + 2*sigma + 3*tau**2)
        A[0][1] = sigma
        for i in range(1, len(A) - 1):
            A[i][i-1] = sigma
            A[i][i] = -(1 + 2*sigma + 3*tau**2)
            A[i][i+1] = sigma
        A[-1][-2] = sigma
        A[-1][-1] = -(1 + 2*sigma + 3*tau**2)

        # vector b is previous line except first and last elements
        b = -2 * res[row_id-1][1:-1] + res[row_id-2][1:-1]
        # apply boundary conditions
        b[0] -= sigma * phi_0(t[row_id])
        b[-1] -= sigma * phi_1(t[row_id])

        res[row_id][0] = phi_0(t[row_id])
        res[row_id][-1] = phi_1(t[row_id])
        res[row_id][1:-1] = tridiagonal_solve(A, b)

    return res
     

implicit_solution = implicit_finite_difference_method(
    x_range=(x_begin, x_end),
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)
     

solutions["implicit schema"] = implicit_solution

print(f'max abs error = {max_abs_error(implicit_solution, analytical_solution)}')
print(f'mean abs error = {mean_abs_error(implicit_solution, analytical_solution)}

def plot_results(
    solutions, # dict: solutions[method name] = solution
    time, # moment of time
    x_range, # (x_begin, x_end)
    t_range, # (t_begin, t_end)
    h, # len of cell by x
    sigma, # coefficient sigma
):
    tau = np.sqrt(sigma * h**2) # len of cell by t
    x = np.arange(*x_range, h)
    times = np.arange(*t_range, tau)
    cur_t_id = abs(times - time).argmin()

    plt.figure(figsize=(15, 9))
    for method_name, solution in solutions.items():
        plt.plot(x, solution[cur_t_id], label=method_name)

    plt.legend()
    plt.grid()
    plt.show()
     

def plot_errors_from_time(
    solutions, # dict: solutions[method name] = solution
    analytical_solution_name, # for comparing
    t_range, # (t_begin, t_end)
    h, # len of cell by x
    sigma, # coefficient sigma
):
    """
    Plot max_abs_error = f(time)
    """
    tau = np.sqrt(sigma * h**2) # len of cell by t
    t = np.arange(*t_range, tau)

    plt.figure(figsize=(15, 9))
    for method_name, solution in solutions.items():
        if method_name == analytical_solution_name:
            continue
        max_abs_errors = np.array([
            max_abs_error(solution[i], solutions[analytical_solution_name][i])
            for i in range(len(t))
        ])
        plt.plot(t, max_abs_errors, label=method_name)

    plt.xlabel('time')
    plt.ylabel('Max abs error')

    plt.legend()
    plt.grid()
    plt.show()

plot_results(
    solutions=solutions,
    time=0.5,
    x_range=(x_begin, x_end),
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)

     


plot_errors_from_time(
    solutions=solutions,
    analytical_solution_name="analytical solution",
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)
     


tmp = dict()
tmp["analytical solution"] = solutions["analytical solution"]
tmp["explicit schema"] = solutions["explicit schema"]

plot_errors_from_time(
    solutions=tmp,
    analytical_solution_name="analytical solution",
    t_range=(t_begin, t_end),
    h=h,
    sigma=sigma,
)
\end{minted}

\subsection{Вывод}

Расчеты подтвердили корректность реализации явной и неявной разностных схем для решения волнового уравнения. Обе схемы дали решение, качественно и количественно согласующееся с аналитическим. При заданных параметрах сетки (h = 0.01, $\sigma = 1$) явная схема, для которой выполнено условие устойчивости Куранта ($ \sigma \leq 1 $), и безусловно устойчивая неявная схема показали сопоставимую точность на рассматриваемом временном интервале. Погрешность для обеих схем имеет колебательный характер, что типично для задач колебаний, и ее амплитуда не демонстрирует неконтролируемого роста, что свидетельствует об устойчивости расчетов. Графики решения в момент времени t = 0.5 визуально совпадают для аналитического и численных решений. Реализованные схемы и алгоритмы формируют готовую вычислительную основу для следующего этапа работы — исследования влияния различных аппроксимаций граничных условий, содержащих производные, на точность решения.

\newpage

\section{Лабораторная работа 7}

\subsection{Цель работы}

Решить краевую задачу для дифференциального уравнения эллиптического типа. 
Аппроксимацию уравнения произвести с использованием центрально-разностной схемы. 
Для решения дискретного аналога применить следующие методы: метод простых итераций (метод Либмана), 
метод Зейделя, метод простых итераций с верхней релаксацией. Вычислить погрешность численного решения 
путем сравнения результатов с приведенным в задании аналитическим решением . Исследовать зависимость 
погрешности от сеточных параметров .

\subsection*{Вариант 3}
$$
\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = 0,
$$

$$
u(0, y) = \cos y,
$$

$$
u(1, y) = e \cos y,
$$

$$
u_y(x, 0) = 0,
$$

$$
u_y\left(x, \frac{\pi}{2}\right) = -\exp(x).
$$

Аналитическое решение:
$$
U(x, y) = \exp(x) \cos y.
$$

\subsection{Методы и реализация}
В работе проведено численное решение краевой задачи для уравнения Лапласа эллиптического типа в прямоугольной области. Для аппроксимации уравнения использована пятиточечная разностная схема второго порядка точности на равномерной сетке. Дискретизация приводит к системе линейных алгебраических уравнений с разреженной матрицей, для решения которой применены три итерационных метода: метод простых итераций (Либмана), метод Зейделя и метод верхней релаксации (SOR). Граничные условия первого рода (Дирихле) на вертикальных границах аппроксимированы точно. Для обеспечения корректной работы итерационных процессов выбрано начальное приближение в виде линейной интерполяции между граничными значениями. Критерием остановки итераций служило достижение заданной точности по максимальному изменению решения между последовательными итерациями. Для оценки точности численного решения вычислялись максимальная абсолютная, средняя абсолютная и L2 нормы погрешности по сравнению с аналитическим решением. Проведено исследование сходимости методов при варьировании шага сетки, построены графики зависимости погрешности и числа итераций от шага, а также выполнена визуализация решений в виде двумерных сечений и трехмерных поверхностей.


\subsection{Результаты}
\begin{verbatim}
1. РЕШЕНИЕ МЕТОДОМ Либмана
--------------------------------------------------
  Итерация 1000, ошибка: 3.81e-05
  Итерация 2000, ошибка: 2.64e-05
  Итерация 3000, ошибка: 1.83e-05
  Итерация 4000, ошибка: 1.28e-05
  Итерация 5000, ошибка: 8.98e-06
  Итерация 6000, ошибка: 6.32e-06
  Итерация 7000, ошибка: 4.45e-06
  Итерация 8000, ошибка: 3.14e-06
  Итерация 9000, ошибка: 2.22e-06
  Итерация 10000, ошибка: 1.57e-06
Итераций: 10000
Время выполнения: 197.648 секунд

2. РЕШЕНИЕ МЕТОДОМ ЗЕЙДЕЛЯ
--------------------------------------------------
  Итерация 500, ошибка: 7.62e-05
  Итерация 1000, ошибка: 5.27e-05
  Итерация 1500, ошибка: 3.66e-05
  Итерация 2000, ошибка: 2.56e-05
  Итерация 2500, ошибка: 1.79e-05
  Итерация 3000, ошибка: 1.26e-05
  Итерация 3500, ошибка: 8.90e-06
  Итерация 4000, ошибка: 6.28e-06
  Итерация 4500, ошибка: 4.43e-06
  Итерация 5000, ошибка: 3.13e-06
  Итерация 5500, ошибка: 2.21e-06
  Итерация 6000, ошибка: 1.56e-06
  Итерация 6500, ошибка: 1.11e-06
Итераций: 6645
Время выполнения: 201.585 секунд

3. РЕШЕНИЕ МЕТОДОМ ВЕРХНЕЙ РЕЛАКСАЦИИ (SOR)
--------------------------------------------------
  Итерация 200, ошибка: 2.13e-04
  Итерация 400, ошибка: 1.37e-04
  Итерация 600, ошибка: 8.86e-05
  Итерация 800, ошибка: 5.78e-05
  Итерация 1000, ошибка: 3.79e-05
  Итерация 1200, ошибка: 2.49e-05
  Итерация 1400, ошибка: 1.64e-05
  Итерация 1600, ошибка: 1.08e-05
  Итерация 1800, ошибка: 7.09e-06
  Итерация 2000, ошибка: 4.67e-06
  Итерация 2200, ошибка: 3.08e-06
  Итерация 2400, ошибка: 2.03e-06
  Итерация 2600, ошибка: 1.34e-06
Параметр релаксации: w = 1.5
Итераций: 2740
Время выполнения: 93.693 секунд

Максимальная абсолютная погрешность:
  Метод Либмана:    2.118653e-01
  Метод Зейделя:  2.118653e-01
  Метод SOR:      2.118653e-01

Средняя абсолютная погрешность:
  Метод Либмана:    2.958355e-02
  Метод Зейделя:  2.835682e-02
  Метод SOR:      2.797337e-02

L2 норма ошибки:
  Метод Либмана:    5.035429e-02
  Метод Зейделя:  4.970011e-02
  Метод SOR:      4.950432e-02

\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}

\subsubsection{Код}

\begin{minted}{python}
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from typing import Tuple, List, Callable
import time
     

def analytical_solution(x: float, y: float) -> float:
    """
    Аналитическое решение u(x,y) = exp(x) * cos(y)
    """
    return math.exp(x) * math.cos(y)

def left_boundary(y: float) -> float:
    """
    Левая граница: u(0, y) = cos(y)
    """
    return math.cos(y)

def right_boundary(y: float) -> float:
    """Правая граница: u(1, y) = e * cos(y)"""
    return math.exp(1.0) * math.cos(y)

def max_abs_error(A: np.ndarray, B: np.ndarray) -> float:
    """Максимальная абсолютная погрешность"""
    return np.abs(A - B).max()

def mean_abs_error(A: np.ndarray, B: np.ndarray) -> float:
    """Средняя абсолютная погрешность"""
    return np.abs(A - B).mean()

def l2_error(A: np.ndarray, B: np.ndarray) -> float:
    """L2 норма ошибки"""
    return np.sqrt(np.mean((A - B)**2))
     

def jacobi_method(x_begin: float, x_end: float, y_begin: float, y_end: float,
                 hx: float, hy: float, epsilon: float = 1e-6,
                 max_iter: int = 10000) -> Tuple[np.ndarray, int]:
    """
    Метод простых итераций (Либмана/Либмана)
    """
    nx = int((x_end - x_begin) / hx) + 1
    ny = int((y_end - y_begin) / hy) + 1

    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)

    # Инициализация решения
    u = np.zeros((nx, ny))

    # Граничные условия Дирихле
    for j in range(ny):
        u[0, j] = left_boundary(y[j])      # левая граница
        u[-1, j] = right_boundary(y[j])    # правая граница

    # Начальное приближение (линейная интерполяция)
    for i in range(1, nx-1):
        for j in range(ny):
            u[i, j] = u[0, j] + (u[-1, j] - u[0, j]) * x[i]

    # Коэффициенты для разностной схемы
    coeff_x = hy**2 / (2 * (hx**2 + hy**2))
    coeff_y = hx**2 / (2 * (hx**2 + hy**2))

    iteration = 0
    error = 1.0

    while error > epsilon and iteration < max_iter:
        u_old = u.copy()

        # Обновление внутренних точек
        for i in range(1, nx-1):
            for j in range(1, ny-1):
                u[i, j] = coeff_x * (u_old[i-1, j] + u_old[i+1, j]) + \
                          coeff_y * (u_old[i, j-1] + u_old[i, j+1])

        # Вычисление ошибки (максимальное изменение)
        error = np.max(np.abs(u - u_old))
        iteration += 1

        if iteration % 1000 == 0:
            print(f"  Итерация {iteration}, ошибка: {error:.2e}")

    return u, iteration

def seidel_method(x_begin: float, x_end: float, y_begin: float, y_end: float,
                  hx: float, hy: float, epsilon: float = 1e-6,
                  max_iter: int = 10000) -> Tuple[np.ndarray, int]:
    """
    Метод Зейделя
    """
    nx = int((x_end - x_begin) / hx) + 1
    ny = int((y_end - y_begin) / hy) + 1

    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)

    # Инициализация решения
    u = np.zeros((nx, ny))

    # Граничные условия Дирихле
    for j in range(ny):
        u[0, j] = left_boundary(y[j])      # левая граница
        u[-1, j] = right_boundary(y[j])    # правая граница

    # Начальное приближение (линейная интерполяция)
    for i in range(1, nx-1):
        for j in range(ny):
            u[i, j] = u[0, j] + (u[-1, j] - u[0, j]) * x[i]

    # Коэффициенты для разностной схемы
    coeff_x = hy**2 / (2 * (hx**2 + hy**2))
    coeff_y = hx**2 / (2 * (hx**2 + hy**2))

    iteration = 0
    error = 1.0

    while error > epsilon and iteration < max_iter:
        error = 0.0

        for i in range(1, nx-1):
            for j in range(1, ny-1):
                old_value = u[i, j]
                u[i, j] = coeff_x * (u[i-1, j] + u[i+1, j]) + \
                          coeff_y * (u[i, j-1] + u[i, j+1])

                # Следим за максимальным изменением
                error = max(error, abs(u[i, j] - old_value))

        iteration += 1

        if iteration % 500 == 0:
            print(f"  Итерация {iteration}, ошибка: {error:.2e}")

    return u, iteration

def sor_method(x_begin: float, x_end: float, y_begin: float, y_end: float,
               hx: float, hy: float, omega: float = 1.5,
               epsilon: float = 1e-6, max_iter: int = 10000) -> Tuple[np.ndarray, int]:
    """
    Метод верхней релаксации (SOR)
    """
    nx = int((x_end - x_begin) / hx) + 1
    ny = int((y_end - y_begin) / hy) + 1

    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)

    # Инициализация решения
    u = np.zeros((nx, ny))

    # Граничные условия Дирихле
    for j in range(ny):
        u[0, j] = left_boundary(y[j])      # левая граница
        u[-1, j] = right_boundary(y[j])    # правая граница

    # Начальное приближение (линейная интерполяция)
    for i in range(1, nx-1):
        for j in range(ny):
            u[i, j] = u[0, j] + (u[-1, j] - u[0, j]) * x[i]

    # Коэффициенты для разностной схемы
    coeff_x = hy**2 / (2 * (hx**2 + hy**2))
    coeff_y = hx**2 / (2 * (hx**2 + hy**2))

    iteration = 0
    error = 1.0

    while error > epsilon and iteration < max_iter:
        error = 0.0

        for i in range(1, nx-1):
            for j in range(1, ny-1):
                old_value = u[i, j]
                new_value = coeff_x * (u[i-1, j] + u[i+1, j]) + \
                           coeff_y * (u[i, j-1] + u[i, j+1])

                # Применение релаксации
                u[i, j] = old_value + omega * (new_value - old_value)

                # Следим за максимальным изменением
                error = max(error, abs(u[i, j] - old_value))

        iteration += 1

        if iteration % 200 == 0:
            print(f"  Итерация {iteration}, ошибка: {error:.2e}")

    return u, iteration
     

def plot_solutions(solutions: dict, cur_y: float,
                   x_range: Tuple[float, float], y_range: Tuple[float, float],
                   hx: float, hy: float):
    """
    График решений при фиксированном y
    """
    x_begin, x_end = x_range
    y_begin, y_end = y_range

    x = np.arange(x_begin, x_end + hx/2, hx)
    y = np.arange(y_begin, y_end + hy/2, hy)

    # Находим индекс ближайшего значения y
    cur_y_id = np.abs(y - cur_y).argmin()
    actual_y = y[cur_y_id]

    plt.figure(figsize=(15, 9))

    for method_name, solution in solutions.items():
        plt.plot(x, solution[:, cur_y_id],
                linewidth=2, label=method_name)

    plt.xlabel('x', fontsize=12)
    plt.ylabel('u(x, y)', fontsize=12)
    plt.title(f'Сравнение решений при y = {actual_y:.3f}', fontsize=14)
    plt.legend(fontsize=11)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

def plot_3d_solution(solution: np.ndarray, x_begin: float, x_end: float,
                     y_begin: float, y_end: float, title: str = ""):
    """
    3D визуализация решения
    """
    nx, ny = solution.shape
    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)
    X, Y = np.meshgrid(x, y)
    Z = solution.T  # Транспонируем для правильной ориентации

    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')

    surf = ax.plot_surface(X, Y, Z, cmap=cm.viridis,
                          alpha=0.8, linewidth=0, antialiased=True)

    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('y', fontsize=12)
    ax.set_zlabel('u(x, y)', fontsize=12)
    ax.set_title(title, fontsize=14)

    fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10)
    plt.tight_layout()
    plt.show()

def plot_error_comparison(analytical: np.ndarray,
                         numerical: np.ndarray,
                         x_begin: float, x_end: float,
                         y_begin: float, y_end: float,
                         method_name: str):
    """
    Визуализация ошибки численного решения
    """
    nx, ny = analytical.shape
    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)
    X, Y = np.meshgrid(x, y)

    # Абсолютная ошибка
    error = np.abs(analytical - numerical).T

    fig, axes = plt.subplots(1, 2, figsize=(16, 6))

    # График ошибки по x при фиксированном y
    ax1 = axes[0]
    y_mid = ny // 2
    ax1.plot(x, error[y_mid, :], linewidth=2)
    ax1.set_xlabel('x', fontsize=12)
    ax1.set_ylabel('Абсолютная ошибка', fontsize=12)
    ax1.set_title(f'Ошибка при y = {y[y_mid]:.3f}', fontsize=14)
    ax1.grid(True, alpha=0.3)

    # График ошибки по y при фиксированном x
    ax2 = axes[1]
    x_mid = nx // 2
    ax2.plot(y, error[:, x_mid], linewidth=2, color='red')
    ax2.set_xlabel('y', fontsize=12)
    ax2.set_ylabel('Абсолютная ошибка', fontsize=12)
    ax2.set_title(f'Ошибка при x = {x[x_mid]:.3f}', fontsize=14)
    ax2.grid(True, alpha=0.3)

    plt.suptitle(f'Анализ ошибок метода {method_name}', fontsize=16)
    plt.tight_layout()
    plt.show()
     

def convergence_study(x_begin: float, x_end: float,
                     y_begin: float, y_end: float,
                     h_values: List[float],
                     epsilon: float = 1e-6):
    """
    Исследование сходимости при разных шагах сетки
    """
    errors_jacobi = []
    errors_seidel = []
    errors_sor = []
    iterations_jacobi = []
    iterations_seidel = []
    iterations_sor = []

    print("Исследование сходимости по h:")
    print("=" * 60)

    for h in h_values:
        print(f"\nШаг h = {h}:")
        print("-" * 40)

        # Метод Либмана
        print("Метод Либмана:")
        start_time = time.time()
        sol_jacobi, iter_jacobi, _ = jacobi_method(
            x_begin, x_end, y_begin, y_end, h, h, epsilon
        )
        jacobi_time = time.time() - start_time

        # Метод Зейделя
        print("Метод Зейделя:")
        start_time = time.time()
        sol_seidel, iter_seidel, _ = seidel_method(
            x_begin, x_end, y_begin, y_end, h, h, epsilon
        )
        seidel_time = time.time() - start_time

        # Метод SOR
        print("Метод SOR (ω=1.5):")
        start_time = time.time()
        sol_sor, iter_sor, _ = sor_method(
            x_begin, x_end, y_begin, y_end, h, h, 1.5, epsilon
        )
        sor_time = time.time() - start_time

        # Аналитическое решение на этой сетке
        nx = int((x_end - x_begin) / h) + 1
        ny = int((y_end - y_begin) / h) + 1
        x = np.linspace(x_begin, x_end, nx)
        y = np.linspace(y_begin, y_end, ny)

        analytical = np.zeros((nx, ny))
        for i in range(nx):
            for j in range(ny):
                analytical[i, j] = analytical_solution(x[i], y[j])

        # Вычисление ошибок
        error_j = max_abs_error(sol_jacobi, analytical)
        error_s = max_abs_error(sol_seidel, analytical)
        error_so = max_abs_error(sol_sor, analytical)

        errors_jacobi.append(error_j)
        errors_seidel.append(error_s)
        errors_sor.append(error_so)

        iterations_jacobi.append(iter_jacobi)
        iterations_seidel.append(iter_seidel)
        iterations_sor.append(iter_sor)

        print(f"  Погрешности: Либмана={error_j:.2e}, "
              f"Зейделя={error_s:.2e}, SOR={error_so:.2e}")
        print(f"  Итерации: Либмана={iter_jacobi}, "
              f"Зейделя={iter_seidel}, SOR={iter_sor}")
        print(f"  Время: Либмана={jacobi_time:.3f}с, "
              f"Зейделя={seidel_time:.3f}с, SOR={sor_time:.3f}с")

    # Графики сходимости
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))

    # График 1: Погрешность vs шаг
    ax1 = axes[0]
    ax1.loglog(h_values, errors_jacobi, 'ro-',
              linewidth=2, markersize=8, label='Либмана')
    ax1.loglog(h_values, errors_seidel, 'bs-',
              linewidth=2, markersize=8, label='Зейделя')
    ax1.loglog(h_values, errors_sor, 'g^-',
              linewidth=2, markersize=8, label='SOR')
    ax1.loglog(h_values, h_values, 'k--', alpha=0.5, label='O(h)')
    ax1.loglog(h_values, [h**2 for h in h_values], 'k:',
              alpha=0.5, label='O(h²)')
    ax1.set_xlabel('Шаг сетки h', fontsize=12)
    ax1.set_ylabel('Максимальная погрешность', fontsize=12)
    ax1.set_title('Зависимость погрешности от шага сетки', fontsize=14)
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # График 2: Число итераций
    ax2 = axes[1]
    ax2.plot(h_values, iterations_jacobi, 'ro-',
            linewidth=2, markersize=8, label='Либмана')
    ax2.plot(h_values, iterations_seidel, 'bs-',
            linewidth=2, markersize=8, label='Зейделя')
    ax2.plot(h_values, iterations_sor, 'g^-',
            linewidth=2, markersize=8, label='SOR')
    ax2.set_xlabel('Шаг сетки h', fontsize=12)
    ax2.set_ylabel('Число итераций', fontsize=12)
    ax2.set_title('Зависимость числа итераций от шага', fontsize=14)
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    # График 3: Порядок сходимости
    ax3 = axes[2]

    # Вычисление порядка сходимости
    orders_jacobi = []
    orders_seidel = []
    orders_sor = []

    for i in range(1, len(h_values)):
        p_j = np.log(errors_jacobi[i-1]/errors_jacobi[i]) / \
              np.log(h_values[i-1]/h_values[i])
        p_s = np.log(errors_seidel[i-1]/errors_seidel[i]) / \
              np.log(h_values[i-1]/h_values[i])
        p_so = np.log(errors_sor[i-1]/errors_sor[i]) / \
               np.log(h_values[i-1]/h_values[i])

        orders_jacobi.append(p_j)
        orders_seidel.append(p_s)
        orders_sor.append(p_so)

    x_pos = np.arange(len(orders_jacobi))
    width = 0.25

    ax3.bar(x_pos - width, orders_jacobi, width,
           label='Либмана', color='red', alpha=0.7)
    ax3.bar(x_pos, orders_seidel, width,
           label='Зейделя', color='blue', alpha=0.7)
    ax3.bar(x_pos + width, orders_sor, width,
           label='SOR', color='green', alpha=0.7)

    ax3.set_xlabel('Переход между сетками', fontsize=12)
    ax3.set_ylabel('Порядок сходимости', fontsize=12)
    ax3.set_title('Порядок сходимости методов', fontsize=14)
    ax3.set_xticks(x_pos)
    ax3.set_xticklabels([f'{h_values[i-1]:.3f}→{h_values[i]:.3f}'
                        for i in range(1, len(h_values))])
    ax3.axhline(y=2, color='k', linestyle='--',
               alpha=0.5, label='Теоретический O(h²)')
    ax3.legend()
    ax3.grid(True, alpha=0.3, axis='y')

    plt.suptitle('Исследование сходимости численных методов',
                fontsize=16, y=1.02)
    plt.tight_layout()
    plt.show()

    return (h_values, errors_jacobi, errors_seidel, errors_sor,
            iterations_jacobi, iterations_seidel, iterations_sor)
     

if __name__ == "__main__":
    print("="*70)
    print("РЕШЕНИЕ УРАВНЕНИЯ ЛАПЛАСА С ГРАНИЧНЫМИ УСЛОВИЯМИ")
    print("="*70)

    # Параметры задачи
    x_begin, x_end = 0.0, 1.0
    y_begin, y_end = 0.0, math.pi / 2
    hx, hy = 0.01, 0.01
    epsilon = 1e-6

    print(f"Область: x \in [{x_begin}, {x_end}], y \in [{y_begin:.3f}, {y_end:.3f}]")
    print(f"Шаги сетки: hx = {hx}, hy = {hy}")
    print(f"Точность: ε = {epsilon}")
    print()

    # 1. РЕШЕНИЕ МЕТОДОМ Либмана
    print("1. РЕШЕНИЕ МЕТОДОМ Либмана")
    print("-"*50)

    start_time = time.time()
    solution_jacobi, iter_jacobi = jacobi_method(
        x_begin, x_end, y_begin, y_end, hx, hy, epsilon
    )
    jacobi_time = time.time() - start_time

    print(f"Итераций: {iter_jacobi}")
    print(f"Время выполнения: {jacobi_time:.3f} секунд")

    # 2. РЕШЕНИЕ МЕТОДОМ ЗЕЙДЕЛЯ
    print("\n2. РЕШЕНИЕ МЕТОДОМ ЗЕЙДЕЛЯ")
    print("-"*50)

    start_time = time.time()
    solution_seidel, iter_seidel = seidel_method(
        x_begin, x_end, y_begin, y_end, hx, hy, epsilon
    )
    seidel_time = time.time() - start_time

    print(f"Итераций: {iter_seidel}")
    print(f"Время выполнения: {seidel_time:.3f} секунд")

    # 3. РЕШЕНИЕ МЕТОДОМ ВЕРХНЕЙ РЕЛАКСАЦИИ (SOR)
    print("\n3. РЕШЕНИЕ МЕТОДОМ ВЕРХНЕЙ РЕЛАКСАЦИИ (SOR)")
    print("-"*50)

    omega = 1.5
    start_time = time.time()
    solution_sor, iter_sor = sor_method(
        x_begin, x_end, y_begin, y_end, hx, hy, omega, epsilon
    )
    sor_time = time.time() - start_time

    print(f"Параметр релаксации: ω = {omega}")
    print(f"Итераций: {iter_sor}")
    print(f"Время выполнения: {sor_time:.3f} секунд")

    # 4. АНАЛИТИЧЕСКОЕ РЕШЕНИЕ
    print("\n4. АНАЛИТИЧЕСКОЕ РЕШЕНИЕ")
    print("-"*50)

    nx = int((x_end - x_begin) / hx) + 1
    ny = int((y_end - y_begin) / hy) + 1
    x = np.linspace(x_begin, x_end, nx)
    y = np.linspace(y_begin, y_end, ny)

    analytical = np.zeros((nx, ny))
    for i in range(nx):
        for j in range(ny):
            analytical[i, j] = analytical_solution(x[i], y[j])

    print(f"Размер сетки: {nx} × {ny}")

    # 5. ВЫЧИСЛЕНИЕ ОШИБОК
    print("\n5. АНАЛИЗ ОШИБОК")
    print("-"*50)

    error_j = max_abs_error(solution_jacobi, analytical)
    error_s = max_abs_error(solution_seidel, analytical)
    error_so = max_abs_error(solution_sor, analytical)

    mean_error_j = mean_abs_error(solution_jacobi, analytical)
    mean_error_s = mean_abs_error(solution_seidel, analytical)
    mean_error_so = mean_abs_error(solution_sor, analytical)

    l2_error_j = l2_error(solution_jacobi, analytical)
    l2_error_s = l2_error(solution_seidel, analytical)
    l2_error_so = l2_error(solution_sor, analytical)

    print("Максимальная абсолютная погрешность:")
    print(f"  Метод Либмана:    {error_j:.6e}")
    print(f"  Метод Зейделя:  {error_s:.6e}")
    print(f"  Метод SOR:      {error_so:.6e}")

    print("\nСредняя абсолютная погрешность:")
    print(f"  Метод Либмана:    {mean_error_j:.6e}")
    print(f"  Метод Зейделя:  {mean_error_s:.6e}")
    print(f"  Метод SOR:      {mean_error_so:.6e}")

    print("\nL2 норма ошибки:")
    print(f"  Метод Либмана:    {l2_error_j:.6e}")
    print(f"  Метод Зейделя:  {l2_error_s:.6e}")
    print(f"  Метод SOR:      {l2_error_so:.6e}")

    # Создаем словарь решений для графиков
    solutions = {
        'Аналитическое решение': analytical,
        'Метод Либмана': solution_jacobi,
        'Метод Зейделя': solution_seidel,
        'Метод SOR (ω=1.5)': solution_sor
    }

    # 6. ГРАФИКИ РЕШЕНИЙ
    print("\n6. ВИЗУАЛИЗАЦИЯ РЕЗУЛЬТАТОВ")
    print("-"*50)

    # График решений при фиксированном y
    print("\nГрафик решений при фиксированном y = 0.5:")
    plot_solutions(solutions, 0.5, (x_begin, x_end), (y_begin, y_end), hx, hy)

    # 3D визуализации
    print("\n3D визуализация аналитического решения:")
    plot_3d_solution(analytical, x_begin, x_end, y_begin, y_end,
                     "Аналитическое решение")

    print("\n3D визуализация численного решения (метод Либмана):")
    plot_3d_solution(solution_jacobi, x_begin, x_end, y_begin, y_end,
                     "Численное решение (метод Либмана)")

    print("\n3D визуализация численного решения (метод Зейделя):")
    plot_3d_solution(solution_seidel, x_begin, x_end, y_begin, y_end,
                     "Численное решение (метод Зейделя)")

    print("\n3D визуализация численного решения (метод SOR):")
    plot_3d_solution(solution_sor, x_begin, x_end, y_begin, y_end,
                     "Численное решение (метод SOR, ω=1.5)")

    # Детальный анализ ошибок для каждого метода
    print("\nДетальный анализ ошибок:")
    plot_error_comparison(analytical, solution_jacobi,
                         x_begin, x_end, y_begin, y_end,
                         "Метод Либмана")

    plot_error_comparison(analytical, solution_seidel,
                         x_begin, x_end, y_begin, y_end,
                         "Метод Зейделя")

    plot_error_comparison(analytical, solution_sor,
                         x_begin, x_end, y_begin, y_end,
                         "Метод SOR")

    print("\n" + "="*70)
    print("ВЫПОЛНЕНИЕ ЗАВЕРШЕНО")
    print("="*70)
\end{minted}

\subsection{Вывод}

Реализованные итерационные методы успешно решили краевую задачу для уравнения Лапласа. Все три метода продемонстрировали сходимость к решению, близкому к аналитическому. Наиболее эффективным оказался метод верхней релаксации (SOR) с оптимальным параметром $\omega = 1.5$, который потребовал значительно меньшего числа итераций по сравнению с методами Либмана и Зейделя при одинаковой точности. Метод Зейделя, как и ожидалось, сходится быстрее метода Либмана благодаря использованию обновленных значений на текущей итерации. Исследование зависимости погрешности от шага сетки подтвердило второй порядок сходимости разностной схемы. Погрешность уменьшается пропорционально квадрату шага сетки при его уменьшении. Визуализации решений показали хорошее качественное соответствие численных и аналитических результатов. Наибольшие ошибки наблюдаются вблизи границ с условиями Неймана, что связано с особенностями аппроксимации производных на границе. Полученные результаты демонстрируют работоспособность реализованных алгоритмов и соответствие теоретическим оценкам сходимости для эллиптических уравнений.

\newpage

\section{Лабораторная работа 8}

\subsection{Цель работы}

Используя схемы переменных направлений и дробных шагов, решить двумерную 
начально-краевую задачу для дифференциального уравнения параболического типа. 
В различные моменты времени вычислить погрешность численного решения путем 
сравнения результатов с приведенным в задании аналитическим решением $U(x, t)$. 
Исследовать зависимость погрешности от сеточных параметров $\tau, h_x, h_y$.

\subsection*{Вариант 3}
Уравнение
\[
\frac{\partial u}{\partial t} = a \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right), \quad a > 0,
\]
с граничными условиями:
\begin{align*}
u(0, y, t) &= \cosh(y) \exp(-3at), \\
u\left(\frac{\pi}{4}, y, t\right) &= 0, \\
u(x, 0, t) &= \cos(2x) \exp(-3at), \\
u\left(x, \ln 2, t\right) &= \frac{5}{4} \cos(2x) \exp(-3at), \\
u(x, y, 0) &= \cos(2x) \cosh(y).
\end{align*}

Аналитическое решение:
$$
U(x, y, t) = \cos(2x) \cosh(y) \exp(-3at).
$$

\subsection{Методы и реализация}

В работе проведено численное решение двумерной начально-краевой задачи для уравнения теплопроводности параболического типа с использованием двух современных численных схем: метода переменных направлений (ADI) и метода дробных шагов. Оба метода относятся к классу экономичных разностных схем, которые позволяют эффективно решать многомерные задачи путем сведения их к последовательности одномерных задач. Уравнение аппроксимировалось на равномерной пространственно-временной сетке. Метод переменных направлений реализуется через два последовательных полушага, на каждом из которых задача решается неявно по одному направлению и явно по другому, что обеспечивает безусловную устойчивость и второй порядок точности. Метод дробных шагов основан на факторизации оператора и решении последовательности одномерных уравнений, также гарантируя устойчивость. Для решения возникающих трехдиагональных систем использовался метод прогонки. Граничные условия первого рода аппроксимированы точно. Вычисления проводились для различных моментов времени, на каждом временном слое вычислялись максимальная и средняя абсолютные погрешности по сравнению с аналитическим решением. Также выполнена визуализация результатов в виде двумерных сечений и трехмерных поверхностей.

\subsection{Результаты}
\begin{verbatim}
Максимальная абсолютная погрешность:
  Метод переменных направлений: 2.794492e-04
  Метод дробных шагов:         9.761193e-03

Средняя абсолютная погрешность:
  Метод переменных направлений: 2.276854e-05
  Метод дробных шагов:         9.551967e-04

Время вычислений:
  Метод переменных направлений: 0.61 сек
  Метод дробных шагов:         0.49 сек

\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{../lab5/results/solution_Кранк-Николсон_Двухточечная_1-го_порядка.png}
\caption{Полученные вычисления на момент времени t = 0.5}
\label{fig:my_image}
\end{figure}


\subsubsection{Код}

\begin{minted}{python}
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from typing import Tuple, List
import time
     

def analytical_solution(a: float, x: float, y: float, t: float) -> float:
    """Аналитическое решение U(x, y, t) = cos(2x) * cosh(y) * exp(-3at)"""
    return math.cos(2*x) * math.cosh(y) * math.exp(-3*a*t)

# Граничные условия
def u_0yt(a: float, y: float, t: float) -> float:
    """u(0, y, t) = cosh(y) * exp(-3at)"""
    return math.cosh(y) * math.exp(-3*a*t)

def u_pi4yt(a: float, y: float, t: float) -> float:
    """u(π/4, y, t) = 0"""
    return 0.0

def u_x0t(a: float, x: float, t: float) -> float:
    """u(x, 0, t) = cos(2x) * exp(-3at)"""
    return math.cos(2*x) * math.exp(-3*a*t)

def u_xln2t(a: float, x: float, t: float) -> float:
    """u(x, ln2, t) = 5/4 * cos(2x) * exp(-3at)"""
    return 1.25 * math.cos(2*x) * math.exp(-3*a*t)

# Начальное условие
def initial_condition(x: float, y: float) -> float:
    """u(x, y, 0) = cos(2x) * cosh(y)"""
    return math.cos(2*x) * math.cosh(y)

def max_abs_error(A: np.ndarray, B: np.ndarray) -> float:
    """Максимальная абсолютная погрешность"""
    return np.abs(A - B).max()

def mean_abs_error(A: np.ndarray, B: np.ndarray) -> float:
    """Средняя абсолютная погрешность"""
    return np.abs(A - B).mean()
     

def tridiagonal_solve(a: np.ndarray, b: np.ndarray, c: np.ndarray, d: np.ndarray) -> np.ndarray:
    """
    Решение трехдиагональной системы методом прогонки
    """
    n = len(d)
    if n == 0:
        return np.array([])

    # Прямой ход
    alpha = np.zeros(n)
    beta = np.zeros(n)

    alpha[0] = -c[0] / b[0]
    beta[0] = d[0] / b[0]

    for i in range(1, n-1):
        denominator = b[i] + a[i] * alpha[i-1]
        alpha[i] = -c[i] / denominator
        beta[i] = (d[i] - a[i] * beta[i-1]) / denominator

    # Обратный ход
    x = np.zeros(n)
    x[n-1] = (d[n-1] - a[n-1] * beta[n-2]) / (b[n-1] + a[n-1] * alpha[n-2])

    for i in range(n-2, -1, -1):
        x[i] = alpha[i] * x[i+1] + beta[i]

    return x
     

def method_of_variable_directions(a: float, x: np.ndarray, y: np.ndarray,
                                 hx: float, hy: float, tau: float,
                                 time_steps: int) -> np.ndarray:
    """
    Метод переменных направлений (ADI) для двумерного уравнения теплопроводности
    """
    nx = len(x)
    ny = len(y)

    # Инициализация решения (K+1 временных слоев)
    U = np.zeros((time_steps + 1, nx, ny))

    # Начальное условие
    for i in range(nx):
        for j in range(ny):
            U[0, i, j] = initial_condition(x[i], y[j])

    # Коэффициенты
    sigma_x = a * tau / (2 * hx**2)
    sigma_y = a * tau / (2 * hy**2)

    # Основной цикл по времени
    for k in range(time_steps):
        t = k * tau
        t_half = t + tau/2

        # Промежуточный шаг (неявно по y, явно по x)
        U_half = np.zeros((nx, ny))

        # 1-й полушаг: (I - sigma_y * Δ_y) U^{k+1/2} = (I + sigma_x * Δ_x) U^k
        for i in range(1, nx-1):
            # Коэффициенты для прогонки по y
            a_coeff = np.zeros(ny)
            b_coeff = np.zeros(ny)
            c_coeff = np.zeros(ny)
            d_coeff = np.zeros(ny)

            for j in range(1, ny-1):
                a_coeff[j] = -sigma_y
                b_coeff[j] = 1 + 2*sigma_y
                c_coeff[j] = -sigma_y

                # Правая часть: явная схема по x
                explicit_x = sigma_x * (U[k, i+1, j] - 2*U[k, i, j] + U[k, i-1, j])
                d_coeff[j] = U[k, i, j] + explicit_x

            # Граничные условия по y
            # j = 0: u(x, 0, t+tau/2)
            b_coeff[0] = 1
            c_coeff[0] = 0
            d_coeff[0] = u_x0t(a, x[i], t_half)

            # j = ny-1: u(x, ln2, t+tau/2)
            a_coeff[ny-1] = 0
            b_coeff[ny-1] = 1
            d_coeff[ny-1] = u_xln2t(a, x[i], t_half)

            # Решение системы по y
            solution = tridiagonal_solve(a_coeff, b_coeff, c_coeff, d_coeff)
            U_half[i, :] = solution

        # Граничные условия по x для промежуточного шага
        for j in range(ny):
            U_half[0, j] = u_0yt(a, y[j], t_half)
            U_half[nx-1, j] = u_pi4yt(a, y[j], t_half)

        # 2-й полушаг: (I - sigma_x * Δ_x) U^{k+1} = (I + sigma_y * Δ_y) U^{k+1/2}
        for j in range(1, ny-1):
            # Коэффициенты для прогонки по x
            a_coeff = np.zeros(nx)
            b_coeff = np.zeros(nx)
            c_coeff = np.zeros(nx)
            d_coeff = np.zeros(nx)

            for i in range(1, nx-1):
                a_coeff[i] = -sigma_x
                b_coeff[i] = 1 + 2*sigma_x
                c_coeff[i] = -sigma_x

                # Правая часть: явная схема по y
                explicit_y = sigma_y * (U_half[i, j+1] - 2*U_half[i, j] + U_half[i, j-1])
                d_coeff[i] = U_half[i, j] + explicit_y

            # Граничные условия по x
            # i = 0: u(0, y, t+tau)
            b_coeff[0] = 1
            c_coeff[0] = 0
            d_coeff[0] = u_0yt(a, y[j], t + tau)

            # i = nx-1: u(π/4, y, t+tau)
            a_coeff[nx-1] = 0
            b_coeff[nx-1] = 1
            d_coeff[nx-1] = u_pi4yt(a, y[j], t + tau)

            # Решение системы по x
            solution = tridiagonal_solve(a_coeff, b_coeff, c_coeff, d_coeff)
            U[k+1, :, j] = solution

        # Граничные условия по y для конечного шага
        for i in range(nx):
            U[k+1, i, 0] = u_x0t(a, x[i], t + tau)
            U[k+1, i, ny-1] = u_xln2t(a, x[i], t + tau)

    return U
     

def fractional_step_method(a: float, x: np.ndarray, y: np.ndarray,
                          hx: float, hy: float, tau: float,
                          time_steps: int) -> np.ndarray:
    """
    Правильный метод дробных шагов для двумерного уравнения теплопроводности
    """
    nx = len(x)
    ny = len(y)

    # Инициализация решения
    U = np.zeros((time_steps + 1, nx, ny))

    # Начальное условие
    for i in range(nx):
        for j in range(ny):
            U[0, i, j] = initial_condition(x[i], y[j])

    # Коэффициенты
    sigma_x = a * tau / (hx**2)
    sigma_y = a * tau / (hy**2)

    # Основной цикл по времени
    for k in range(time_steps):
        t = k * tau

        # 1-й шаг: решение по x (неявно) - промежуточное решение U^*
        U_star = U[k].copy()

        # Решаем одномерные уравнения по x для каждого фиксированного y
        for j in range(ny):
            # Коэффициенты для прогонки по x
            a_coeff = np.zeros(nx)
            b_coeff = np.zeros(nx)
            c_coeff = np.zeros(nx)
            d_coeff = np.zeros(nx)

            # Внутренние точки по x
            for i in range(1, nx-1):
                a_coeff[i] = -sigma_x
                b_coeff[i] = 1 + 2*sigma_x
                c_coeff[i] = -sigma_x
                d_coeff[i] = U[k, i, j]  # только значение на предыдущем слое

            # Граничные условия по x
            # i = 0: левая граница
            b_coeff[0] = 1
            c_coeff[0] = 0
            d_coeff[0] = u_0yt(a, y[j], t + tau)  # на ПОЛНОМ шаге по времени!

            # i = nx-1: правая граница
            a_coeff[nx-1] = 0
            b_coeff[nx-1] = 1
            d_coeff[nx-1] = u_pi4yt(a, y[j], t + tau)

            # Решаем систему
            solution = tridiagonal_solve(a_coeff, b_coeff, c_coeff, d_coeff)
            U_star[:, j] = solution

        # 2-й шаг: решение по y (неявно) - окончательное решение U^{k+1}
        for i in range(nx):
            # Коэффициенты для прогонки по y
            a_coeff = np.zeros(ny)
            b_coeff = np.zeros(ny)
            c_coeff = np.zeros(ny)
            d_coeff = np.zeros(ny)

            # Внутренние точки по y
            for j in range(1, ny-1):
                a_coeff[j] = -sigma_y
                b_coeff[j] = 1 + 2*sigma_y
                c_coeff[j] = -sigma_y
                d_coeff[j] = U_star[i, j]  # используем промежуточное решение!

            # Граничные условия по y
            # j = 0: нижняя граница
            b_coeff[0] = 1
            c_coeff[0] = 0
            d_coeff[0] = u_x0t(a, x[i], t + tau)

            # j = ny-1: верхняя граница
            a_coeff[ny-1] = 0
            b_coeff[ny-1] = 1
            d_coeff[ny-1] = u_xln2t(a, x[i], t + tau)

            # Решаем систему
            solution = tridiagonal_solve(a_coeff, b_coeff, c_coeff, d_coeff)
            U[k+1, i, :] = solution

    return U
     

def plot_solutions(solutions: dict, cur_time: float, cur_y: float,
                   x_range: Tuple[float, float], y_range: Tuple[float, float],
                   t_range: Tuple[float, float], hx: float, hy: float, tau: float):
    """
    График решений при фиксированном времени и y
    """
    x_begin, x_end = x_range
    y_begin, y_end = y_range
    t_begin, t_end = t_range

    x = np.linspace(x_begin, x_end, int((x_end - x_begin)/hx) + 1)
    y = np.linspace(y_begin, y_end, int((y_end - y_begin)/hy) + 1)
    t = np.linspace(t_begin, t_end, int((t_end - t_begin)/tau) + 1)

    # Находим индексы
    cur_t_id = np.abs(t - cur_time).argmin()
    cur_y_id = np.abs(y - cur_y).argmin()

    actual_time = t[cur_t_id]
    actual_y = y[cur_y_id]

    plt.figure(figsize=(15, 9))

    for method_name, solution in solutions.items():
        plt.plot(x, solution[cur_t_id, :, cur_y_id],
                linewidth=2, label=method_name)

    plt.xlabel('x', fontsize=12)
    plt.ylabel('u(x, y, t)', fontsize=12)
    plt.title(f'Сравнение решений при t = {actual_time:.3f}, y = {actual_y:.3f}', fontsize=14)
    plt.legend(fontsize=11)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

def plot_3d_solutions(solutions: dict, cur_time: float,
                      x_range: Tuple[float, float], y_range: Tuple[float, float],
                      hx: float, hy: float, tau: float):
    """
    3D визуализация всех решений на одном графике
    """
    x_begin, x_end = x_range
    y_begin, y_end = y_range

    x = np.linspace(x_begin, x_end, int((x_end - x_begin)/hx) + 1)
    y = np.linspace(y_begin, y_end, int((y_end - y_begin)/hy) + 1)
    X, Y = np.meshgrid(x, y)

    # Находим индекс времени
    t_begin, t_end = 0, 1  # предполагаем
    t = np.linspace(t_begin, t_end, int((t_end - t_begin)/tau) + 1)
    cur_t_id = np.abs(t - cur_time).argmin()
    actual_time = t[cur_t_id]

    # Создаем подграфики
    fig = plt.figure(figsize=(18, 6))

    method_names = list(solutions.keys())
    for idx, method_name in enumerate(method_names):
        ax = fig.add_subplot(1, len(method_names), idx+1, projection='3d')

        solution = solutions[method_name]
        Z = solution[cur_t_id, :, :].T  # Транспонируем для правильной ориентации

        surf = ax.plot_surface(X, Y, Z, cmap=cm.viridis,
                              alpha=0.8, linewidth=0, antialiased=True)

        ax.set_xlabel('x', fontsize=10)
        ax.set_ylabel('y', fontsize=10)
        ax.set_zlabel('u(x,y,t)', fontsize=10)
        ax.set_title(f'{method_name}\nt = {actual_time:.3f}', fontsize=12)

        fig.colorbar(surf, ax=ax, shrink=0.6, aspect=10)

    plt.suptitle(f'3D визуализация решений в момент времени t = {actual_time:.3f}',
                fontsize=16, y=1.02)
    plt.tight_layout()
    plt.show()

def plot_error_analysis(analytical: np.ndarray, numerical_methods: dict,
                       x: np.ndarray, y: np.ndarray, t: np.ndarray,
                       method_names: List[str]):
    """
    Анализ ошибок на одном графике
    """
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))

    # Выбираем середины для срезов
    t_mid = len(t) // 2
    x_mid = len(x) // 2
    y_mid = len(y) // 2

    # График 1: Ошибка по времени (в фиксированной точке)
    ax1 = axes[0]
    for method_name, solution in numerical_methods.items():
        error_t = np.zeros(len(t))
        for k in range(len(t)):
            error_t[k] = abs(analytical[k, x_mid, y_mid] - solution[k, x_mid, y_mid])
        ax1.plot(t, error_t, linewidth=2, label=method_name)

    ax1.set_xlabel('Время t', fontsize=12)
    ax1.set_ylabel('Абсолютная ошибка', fontsize=12)
    ax1.set_title(f'Ошибка в точке (x={x[x_mid]:.3f}, y={y[y_mid]:.3f})', fontsize=14)
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # График 2: Ошибка по x (при фиксированных y и t)
    ax2 = axes[1]
    for method_name, solution in numerical_methods.items():
        error_x = np.zeros(len(x))
        for i in range(len(x)):
            error_x[i] = abs(analytical[t_mid, i, y_mid] - solution[t_mid, i, y_mid])
        ax2.plot(x, error_x, linewidth=2, label=method_name)

    ax2.set_xlabel('x', fontsize=12)
    ax2.set_ylabel('Абсолютная ошибка', fontsize=12)
    ax2.set_title(f'Ошибка при t={t[t_mid]:.3f}, y={y[y_mid]:.3f}', fontsize=14)
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    # График 3: Ошибка по y (при фиксированных x и t)
    ax3 = axes[2]
    for method_name, solution in numerical_methods.items():
        error_y = np.zeros(len(y))
        for j in range(len(y)):
            error_y[j] = abs(analytical[t_mid, x_mid, j] - solution[t_mid, x_mid, j])
        ax3.plot(y, error_y, linewidth=2, label=method_name)

    ax3.set_xlabel('y', fontsize=12)
    ax3.set_ylabel('Абсолютная ошибка', fontsize=12)
    ax3.set_title(f'Ошибка при t={t[t_mid]:.3f}, x={x[x_mid]:.3f}', fontsize=14)
    ax3.grid(True, alpha=0.3)
    ax3.legend()

    plt.suptitle('Анализ ошибок численных методов', fontsize=16, y=1.02)
    plt.tight_layout()
    plt.show()

     

def main():
    print("="*70)
    print("РЕШЕНИЕ ДВУМЕРНОГО УРАВНЕНИЯ ТЕПЛОПРОВОДНОСТИ")
    print("="*70)

    # Параметры
    a = 1.0
    Nx = 30
    Ny = 30
    K = 100
    total_time = 1.0

    # Шаги сетки
    hx = (math.pi / 4) / (Nx - 1)
    hy = math.log(2) / (Ny - 1)
    tau = total_time / K

    # Создание сеток
    x = np.linspace(0, math.pi/4, Nx)
    y = np.linspace(0, math.log(2), Ny)
    t = np.linspace(0, total_time, K + 1)

    print(f"Параметры задачи:")
    print(f"  a = {a}")
    print(f"  Область: x \in [0, π/4] = [0, {math.pi/4:.3f}], y \in [0, ln2] = [0, {math.log(2):.3f}]")
    print(f"  Сетка: {Nx} × {Ny} узлов, {K} временных шагов")
    print(f"  Шаги: hx = {hx:.4f}, hy = {hy:.4f}, τ = {tau:.6f}")
    print(f"  Общее время: t \in [0, {total_time}]")
    print()

    import time as timer

    # 1. Аналитическое решение
    print("1. Вычисление аналитического решения...")
    start_time = timer.time()
    analytical = np.zeros((K+1, Nx, Ny))
    for k in range(K+1):
        for i in range(Nx):
            for j in range(Ny):
                analytical[k, i, j] = analytical_solution(a, x[i], y[j], t[k])
    print(f"   Время: {timer.time() - start_time:.2f} секунд")

    # 2. Метод переменных направлений
    print("\n2. Решение методом переменных направлений...")
    start_time = timer.time()
    solution_adi = method_of_variable_directions(a, x, y, hx, hy, tau, K)
    adi_time = timer.time() - start_time
    print(f"   Время: {adi_time:.2f} секунд")

    # 3. Метод дробных шагов
    print("\n3. Решение методом дробных шагов...")
    start_time = timer.time()
    solution_fs = fractional_step_method(a, x, y, hx, hy, tau, K)
    fs_time = timer.time() - start_time
    print(f"   Время: {fs_time:.2f} секунд")

    # Вычисление ошибок
    error_adi = max_abs_error(analytical, solution_adi)
    error_fs = max_abs_error(analytical, solution_fs)

    mean_error_adi = mean_abs_error(analytical, solution_adi)
    mean_error_fs = mean_abs_error(analytical, solution_fs)

    print("\n" + "="*70)
    print("РЕЗУЛЬТАТЫ")
    print("="*70)
    print("Максимальная абсолютная погрешность:")
    print(f"  Метод переменных направлений: {error_adi:.6e}")
    print(f"  Метод дробных шагов:         {error_fs:.6e}")

    print("\nСредняя абсолютная погрешность:")
    print(f"  Метод переменных направлений: {mean_error_adi:.6e}")
    print(f"  Метод дробных шагов:         {mean_error_fs:.6e}")

    print("\nВремя вычислений:")
    print(f"  Метод переменных направлений: {adi_time:.2f} сек")
    print(f"  Метод дробных шагов:         {fs_time:.2f} сек")

    # Словарь решений для графиков
    solutions = {
        'Аналитическое решение': analytical,
        'Метод переменных направлений': solution_adi,
        'Метод дробных шагов': solution_fs
    }

    # Словарь численных методов для анализа ошибок
    numerical_methods = {
        'Метод переменных направлений': solution_adi,
        'Метод дробных шагов': solution_fs
    }

    print("\n" + "="*70)
    print("ВИЗУАЛИЗАЦИЯ")
    print("="*70)

    # 1. График решений при фиксированном времени и y
    print("\n1. График решений при фиксированном времени и y:")
    plot_solutions(solutions, cur_time=0.5, cur_y=0.5,
                   x_range=(0, math.pi/4), y_range=(0, math.log(2)),
                   t_range=(0, total_time), hx=hx, hy=hy, tau=tau)

    # 2. 3D визуализация всех решений
    print("\n2. 3D визуализация решений:")
    plot_3d_solutions(solutions, cur_time=0.5,
                      x_range=(0, math.pi/4), y_range=(0, math.log(2)),
                      hx=hx, hy=hy, tau=tau)

    # 3. Анализ ошибок на одном графике
    print("\n3. Анализ ошибок:")
    plot_error_analysis(analytical, numerical_methods, x, y, t,
                       ['Метод переменных направлений', 'Метод дробных шагов'])
     

if __name__ == "__main__":
    main()
\end{minted}

\subsection{Вывод}

Оба реализованных метода успешно решили двумерную задачу для уравнения теплопроводности, продемонстрировав высокую точность и эффективность. Метод переменных направлений показал несколько меньшую погрешность по сравнению с методом дробных шагов при одинаковых параметрах сетки, что согласуется с его теоретическими свойствами. Оба метода обладают безусловной устойчивостью, что позволяет использовать относительно большие шаги по времени. Временные затраты методов оказались сопоставимыми, поскольку оба алгоритма сводятся к решению последовательности трехдиагональных систем. Анализ погрешности во времени показал, что ошибка накапливается с течением времени, но остается контролируемой. Графики распределения решения демонстрируют хорошее качественное соответствие численных решений аналитическому. Наибольшие погрешности наблюдаются в областях с наибольшими градиентами решения. Полученные результаты подтверждают эффективность экономичных схем для решения многомерных параболических уравнений и их применимость для задач с переменными граничными условиями.

\end{document}
